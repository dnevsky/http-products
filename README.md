
# http-products

Согласно ТЗ в этом приложении реализовано HTTP API с единственной ручкой - `GET /`.
При запросе на эту ручку должны возвращаться данные о продуктах с пагинацией. limit и offset передаются через query params.

Для этих данных был реализован опережающий кэш (ahead cache). Данные при обработке запроса получаются только из него.

Для роутинга запросов использовалась библиотека `gin-gonic/gin`.
Для логирования использовалась библиотека `zap`.

Заполнение таблицы тестовыми значениями - `python million.py`.

!!! Пока что приложение запускается не в Docker контейнере, поэтому в .env указывайте не название контейнера, а localhost с портом.

## `.env` переменные:

```
DB_URI="postgres://postgres:qwerty@127.0.0.1:5432/testdb?sslmode=disable"

APP_PORT = "5000"

REDIS_ADDR="localhost:6379"
REDIS_PASSWD="asdzxc"
REDIS_DB=0

POSTGRES_DB=testdb
POSTGRES_USER=postgres
POSTGRES_PASSWORD=qwerty
```

## `Makefile`:

`make postgre` - поднять базу данных Postgres в Docker.

`make redis` - поднять Redis в Docker.

`make create-migrate` - создать файлы миграции. Перед использованием нужно указать название миграции.

`make migrate` - применить миграцию.

`make shutdown` - завершение всех запущенных приложений.

## Комментарии:

### Хранение снапшота таблицы в кэше.

Поскольку мы работаем через кэш Redis нужно было придумать как хранить всю таблицу в кэше.

Самым простым вариантом который мне пришел на ум - списки в Redis. В нашем случае удобный доступ к данным.

Следующая проблема - сериализация данных для хранения. У нас сложный (относительно списка) обьект, поэтому у меня было несколько вариантов.
- Либо создавать два списка и в первом хранить id, а во втором price.
- Либо создать один список и хранить в нём json строку (приложение будет тратить время на де/сериализацию данных)
- Либо создать один список и хранить в нём строку формата `id:price`.

Первый способ я не проверял, сразу показался сомнительным решением и по итогу проверок самым быстрым оказался третий способ - `id:price`.

Сериализация при помощи `json` в среднем на 0.1 секунду дольше, чем `id:price` (~1 сек против ~0.9 сек), но мы теряем удобство разработки.. Можно было бы попробовать хранить бинарники GRPC, но не знаю что из этого выйдет)

### Обновление данных в кэше спустя какое-то время.

Поскольку мы работаем со списком мы не можем просто взять и заменить значения на свои по индексу. Встроенные решения Redis вроде бы не позволяют это сделать. Команда, которой можно заменить значение по индексу принимает только один индекс и одно значение, а долбить Redis 1 миллионом запросов крайне неэффективно. Поэтому я использую классический список, в которую записываю обьект в формате JSON строки. Перед вставкой новых элементов я полностью удаляю products, а потом уже вставляю в список свои строки. Что-бы обеспечить атомарность я использовал транзакцию.
